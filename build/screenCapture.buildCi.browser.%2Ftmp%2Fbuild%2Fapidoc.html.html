<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/bitinn/node-fetch">node-fetch (v1.6.3)</a>
</h1>
<h4>A light-weight module that brings window.fetch to node.js and io.js</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch">module node-fetch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.node-fetch">
            function <span class="apidocSignatureSpan"></span>node-fetch
            <span class="apidocSignatureSpan">(url, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Headers">
            function <span class="apidocSignatureSpan">node-fetch.</span>Headers
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Promise">
            function <span class="apidocSignatureSpan">node-fetch.</span>Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Request">
            function <span class="apidocSignatureSpan">node-fetch.</span>Request
            <span class="apidocSignatureSpan">(input, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Response">
            function <span class="apidocSignatureSpan">node-fetch.</span>Response
            <span class="apidocSignatureSpan">(body, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.body">
            function <span class="apidocSignatureSpan">node-fetch.</span>body
            <span class="apidocSignatureSpan">(body, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.default">
            function <span class="apidocSignatureSpan">node-fetch.</span>default
            <span class="apidocSignatureSpan">(url, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.fetch_error">
            function <span class="apidocSignatureSpan">node-fetch.</span>fetch_error
            <span class="apidocSignatureSpan">(message, type, systemError)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-fetch.</span>Headers.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-fetch.</span>Request.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-fetch.</span>Response.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-fetch.</span>body.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">node-fetch.</span>default.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch.Headers">module node-fetch.Headers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Headers.Headers">
            function <span class="apidocSignatureSpan">node-fetch.</span>Headers
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch.Headers.prototype">module node-fetch.Headers.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Headers.prototype.append">
            function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>append
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Headers.prototype.delete">
            function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>delete
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Headers.prototype.forEach">
            function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Headers.prototype.get">
            function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>get
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Headers.prototype.getAll">
            function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>getAll
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Headers.prototype.has">
            function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>has
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Headers.prototype.raw">
            function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>raw
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Headers.prototype.set">
            function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>set
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch.Request">module node-fetch.Request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Request.Request">
            function <span class="apidocSignatureSpan">node-fetch.</span>Request
            <span class="apidocSignatureSpan">(input, init)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch.Request.prototype">module node-fetch.Request.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Request.prototype.clone">
            function <span class="apidocSignatureSpan">node-fetch.Request.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch.Response">module node-fetch.Response</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Response.Response">
            function <span class="apidocSignatureSpan">node-fetch.</span>Response
            <span class="apidocSignatureSpan">(body, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch.Response.prototype">module node-fetch.Response.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.Response.prototype.clone">
            function <span class="apidocSignatureSpan">node-fetch.Response.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch.body">module node-fetch.body</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.body.body">
            function <span class="apidocSignatureSpan">node-fetch.</span>body
            <span class="apidocSignatureSpan">(body, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.body.Promise">
            function <span class="apidocSignatureSpan">node-fetch.body.</span>Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch.body.prototype">module node-fetch.body.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.body.prototype._clone">
            function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>_clone
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.body.prototype._convert">
            function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>_convert
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.body.prototype._decode">
            function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>_decode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.body.prototype.buffer">
            function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>buffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.body.prototype.json">
            function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>json
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.body.prototype.text">
            function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>text
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch.default">module node-fetch.default</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.default.default">
            function <span class="apidocSignatureSpan">node-fetch.</span>default
            <span class="apidocSignatureSpan">(url, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.default.Headers">
            function <span class="apidocSignatureSpan">node-fetch.default.</span>Headers
            <span class="apidocSignatureSpan">(headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.default.Promise">
            function <span class="apidocSignatureSpan">node-fetch.default.</span>Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.default.Request">
            function <span class="apidocSignatureSpan">node-fetch.default.</span>Request
            <span class="apidocSignatureSpan">(input, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.default.Response">
            function <span class="apidocSignatureSpan">node-fetch.default.</span>Response
            <span class="apidocSignatureSpan">(body, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch.default.prototype">module node-fetch.default.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.default.prototype.isRedirect">
            function <span class="apidocSignatureSpan">node-fetch.default.prototype.</span>isRedirect
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.node-fetch.fetch_error">module node-fetch.fetch_error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.fetch_error.fetch_error">
            function <span class="apidocSignatureSpan">node-fetch.</span>fetch_error
            <span class="apidocSignatureSpan">(message, type, systemError)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.node-fetch.fetch_error.super_">
            function <span class="apidocSignatureSpan">node-fetch.fetch_error.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch" id="apidoc.module.node-fetch">module node-fetch</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.node-fetch" id="apidoc.element.node-fetch.node-fetch">
        function <span class="apidocSignatureSpan"></span>node-fetch
        <span class="apidocSignatureSpan">(url, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fetch(url, opts) {

	// allow call as function
	if (!(this instanceof Fetch))
		return new Fetch(url, opts);

	// allow custom promise
	if (!Fetch.Promise) {
		throw new Error('native promise missing, set Fetch.Promise to your favorite alternative');
	}

	Body.Promise = Fetch.Promise;

	var self = this;

	// wrap http.request into fetch
	return new Fetch.Promise(function(resolve, reject) {
		// build request object
		var options = new Request(url, opts);

		if (!options.protocol || !options.hostname) {
			throw new Error('only absolute urls are supported');
		}

		if (options.protocol !== 'http:' &amp;&amp; options.protocol !== 'https:') {
			throw new Error('only http(s) protocols are supported');
		}

		var send;
		if (options.protocol === 'https:') {
			send = https.request;
		} else {
			send = http.request;
		}

		// normalize headers
		var headers = new Headers(options.headers);

		if (options.compress) {
			headers.set('accept-encoding', 'gzip,deflate');
		}

		if (!headers.has('user-agent')) {
			headers.set('user-agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
		}

		if (!headers.has('connection') &amp;&amp; !options.agent) {
			headers.set('connection', 'close');
		}

		if (!headers.has('accept')) {
			headers.set('accept', '*/*');
		}

		// detect form data input from form-data module, this hack avoid the need to pass multipart header manually
		if (!headers.has('content-type') &amp;&amp; options.body &amp;&amp; typeof options.body.getBoundary === 'function') {
			headers.set('content-type', 'multipart/form-data; boundary=' + options.body.getBoundary());
		}

		// bring node-fetch closer to browser behavior by setting content-length automatically
		if (!headers.has('content-length') &amp;&amp; /post|put|patch|delete/i.test(options.method)) {
			if (typeof options.body === 'string') {
				headers.set('content-length', Buffer.byteLength(options.body));
			// detect form data input from form-data module, this hack avoid the need to add content-length header manually
			} else if (options.body &amp;&amp; typeof options.body.getLengthSync === 'function') {
				// for form-data 1.x
				if (options.body._lengthRetrievers &amp;&amp; options.body._lengthRetrievers.length == 0) {
					headers.set('content-length', options.body.getLengthSync().toString());
				// for form-data 2.x
				} else if (options.body.hasKnownLength &amp;&amp; options.body.hasKnownLength()) {
					headers.set('content-length', options.body.getLengthSync().toString());
				}
			// this is only necessary for older nodejs releases (before iojs merge)
			} else if (options.body === undefined || options.body === null) {
				headers.set('content-length', '0');
			}
		}

		options.headers = headers.raw();

		// http.request only support string as host header, this hack make custom host header possible
		if (options.headers.host) {
			options.headers.host = options.headers.host[0];
		}

		// send request
		var req = send(options);
		var reqTimeout;

		if (options.timeout) {
			req.once('socket', function(socket) {
				reqTimeout = setTimeout(function() {
					req.abort();
					reject(new FetchError('network timeout at: ' + options.url, 'request-timeout'));
				}, options.timeout);
			});
		}

		req.on('error', function(err) {
			clearTimeout(reqTimeout);
			reject(new FetchError('request to ' + options.url + ' failed, reason: ' + err.message, 'system', err));
		});

		req.on('response', function(res) {
			clearTimeout(reqTimeout);

			// handle redirect
			if (self.isRedirect(res.statusCode) &amp;&amp; options.redirect !== 'manual') {
				if (options.redirect === 'error') {
					reject(new FetchError('redirect mode is set to error: ' + options.url, 'no-redirect'));
					return;
				}

				if (options.counter &gt;= options.follow) {
					reject(new FetchError('maximum redirect reached at: ' + options.url, 'max-redirect'));
					return;
				}

				if (!res.headers.location) {
					reject(new FetchError('redirect location header missing at: ' + options.url, 'invalid-redirect'));
					return;
				}

				// per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET wh ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.Headers" id="apidoc.element.node-fetch.Headers">
        function <span class="apidocSignatureSpan">node-fetch.</span>Headers
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Headers(headers) {

	var self = this;
	this._headers = {};

	// Headers
	if (headers instanceof Headers) {
		headers = headers.raw();
	}

	// plain object
	for (var prop in headers) {
		if (!headers.hasOwnProperty(prop)) {
			continue;
		}

		if (typeof headers[prop] === 'string') {
			this.set(prop, headers[prop]);

		} else if (typeof headers[prop] === 'number' &amp;&amp; !isNaN(headers[prop])) {
			this.set(prop, headers[prop].toString());

		} else if (headers[prop] instanceof Array) {
			headers[prop].forEach(function(item) {
				self.append(prop, item.toString());
			});
		}
	}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.Promise" id="apidoc.element.node-fetch.Promise">
        function <span class="apidocSignatureSpan">node-fetch.</span>Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}

	Body.Promise = Fetch.Promise;

	var self = this;

	// wrap http.request into fetch
	return new Fetch.<span class="apidocCodeKeywordSpan">Promise</span>(function(resolve, reject) {
		// build request object
		var options = new Request(url, opts);

		if (!options.protocol || !options.hostname) {
			throw new Error('only absolute urls are supported');
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.Request" id="apidoc.element.node-fetch.Request">
        function <span class="apidocSignatureSpan">node-fetch.</span>Request
        <span class="apidocSignatureSpan">(input, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Request(input, init) {
	var url, url_parsed;

	// normalize input
	if (!(input instanceof Request)) {
		url = input;
		url_parsed = parse_url(url);
		input = {};
	} else {
		url = input.url;
		url_parsed = parse_url(url);
	}

	// normalize init
	init = init || {};

	// fetch spec options
	this.method = init.method || input.method || 'GET';
	this.redirect = init.redirect || input.redirect || 'follow';
	this.headers = new Headers(init.headers || input.headers || {});
	this.url = url;

	// server only options
	this.follow = init.follow !== undefined ?
		init.follow : input.follow !== undefined ?
		input.follow : 20;
	this.compress = init.compress !== undefined ?
		init.compress : input.compress !== undefined ?
		input.compress : true;
	this.counter = init.counter || input.counter || 0;
	this.agent = init.agent || input.agent;

	Body.call(this, init.body || this._clone(input), {
		timeout: init.timeout || input.timeout || 0,
		size: init.size || input.size || 0
	});

	// server request options
	this.protocol = url_parsed.protocol;
	this.hostname = url_parsed.hostname;
	this.port = url_parsed.port;
	this.path = url_parsed.path;
	this.auth = url_parsed.auth;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.Response" id="apidoc.element.node-fetch.Response">
        function <span class="apidocSignatureSpan">node-fetch.</span>Response
        <span class="apidocSignatureSpan">(body, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Response(body, opts) {

	opts = opts || {};

	this.url = opts.url;
	this.status = opts.status || 200;
	this.statusText = opts.statusText || http.STATUS_CODES[this.status];
	this.headers = new Headers(opts.headers);
	this.ok = this.status &gt;= 200 &amp;&amp; this.status &lt; 300;

	Body.call(this, body, opts);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.body" id="apidoc.element.node-fetch.body">
        function <span class="apidocSignatureSpan">node-fetch.</span>body
        <span class="apidocSignatureSpan">(body, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Body(body, opts) {

	opts = opts || {};

	this.body = body;
	this.bodyUsed = false;
	this.size = opts.size || 0;
	this.timeout = opts.timeout || 0;
	this._raw = [];
	this._abort = false;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.default" id="apidoc.element.node-fetch.default">
        function <span class="apidocSignatureSpan">node-fetch.</span>default
        <span class="apidocSignatureSpan">(url, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fetch(url, opts) {

	// allow call as function
	if (!(this instanceof Fetch))
		return new Fetch(url, opts);

	// allow custom promise
	if (!Fetch.Promise) {
		throw new Error('native promise missing, set Fetch.Promise to your favorite alternative');
	}

	Body.Promise = Fetch.Promise;

	var self = this;

	// wrap http.request into fetch
	return new Fetch.Promise(function(resolve, reject) {
		// build request object
		var options = new Request(url, opts);

		if (!options.protocol || !options.hostname) {
			throw new Error('only absolute urls are supported');
		}

		if (options.protocol !== 'http:' &amp;&amp; options.protocol !== 'https:') {
			throw new Error('only http(s) protocols are supported');
		}

		var send;
		if (options.protocol === 'https:') {
			send = https.request;
		} else {
			send = http.request;
		}

		// normalize headers
		var headers = new Headers(options.headers);

		if (options.compress) {
			headers.set('accept-encoding', 'gzip,deflate');
		}

		if (!headers.has('user-agent')) {
			headers.set('user-agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
		}

		if (!headers.has('connection') &amp;&amp; !options.agent) {
			headers.set('connection', 'close');
		}

		if (!headers.has('accept')) {
			headers.set('accept', '*/*');
		}

		// detect form data input from form-data module, this hack avoid the need to pass multipart header manually
		if (!headers.has('content-type') &amp;&amp; options.body &amp;&amp; typeof options.body.getBoundary === 'function') {
			headers.set('content-type', 'multipart/form-data; boundary=' + options.body.getBoundary());
		}

		// bring node-fetch closer to browser behavior by setting content-length automatically
		if (!headers.has('content-length') &amp;&amp; /post|put|patch|delete/i.test(options.method)) {
			if (typeof options.body === 'string') {
				headers.set('content-length', Buffer.byteLength(options.body));
			// detect form data input from form-data module, this hack avoid the need to add content-length header manually
			} else if (options.body &amp;&amp; typeof options.body.getLengthSync === 'function') {
				// for form-data 1.x
				if (options.body._lengthRetrievers &amp;&amp; options.body._lengthRetrievers.length == 0) {
					headers.set('content-length', options.body.getLengthSync().toString());
				// for form-data 2.x
				} else if (options.body.hasKnownLength &amp;&amp; options.body.hasKnownLength()) {
					headers.set('content-length', options.body.getLengthSync().toString());
				}
			// this is only necessary for older nodejs releases (before iojs merge)
			} else if (options.body === undefined || options.body === null) {
				headers.set('content-length', '0');
			}
		}

		options.headers = headers.raw();

		// http.request only support string as host header, this hack make custom host header possible
		if (options.headers.host) {
			options.headers.host = options.headers.host[0];
		}

		// send request
		var req = send(options);
		var reqTimeout;

		if (options.timeout) {
			req.once('socket', function(socket) {
				reqTimeout = setTimeout(function() {
					req.abort();
					reject(new FetchError('network timeout at: ' + options.url, 'request-timeout'));
				}, options.timeout);
			});
		}

		req.on('error', function(err) {
			clearTimeout(reqTimeout);
			reject(new FetchError('request to ' + options.url + ' failed, reason: ' + err.message, 'system', err));
		});

		req.on('response', function(res) {
			clearTimeout(reqTimeout);

			// handle redirect
			if (self.isRedirect(res.statusCode) &amp;&amp; options.redirect !== 'manual') {
				if (options.redirect === 'error') {
					reject(new FetchError('redirect mode is set to error: ' + options.url, 'no-redirect'));
					return;
				}

				if (options.counter &gt;= options.follow) {
					reject(new FetchError('maximum redirect reached at: ' + options.url, 'max-redirect'));
					return;
				}

				if (!res.headers.location) {
					reject(new FetchError('redirect location header missing at: ' + options.url, 'invalid-redirect'));
					return;
				}

				// per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET wh ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.fetch_error" id="apidoc.element.node-fetch.fetch_error">
        function <span class="apidocSignatureSpan">node-fetch.</span>fetch_error
        <span class="apidocSignatureSpan">(message, type, systemError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FetchError(message, type, systemError) {

	// hide custom error implementation details from end-users
	Error.captureStackTrace(this, this.constructor);

	this.name = this.constructor.name;
	this.message = message;
	this.type = type;

	// when err.type is `system`, err.code contains system error code
	if (systemError) {
		this.code = this.errno = systemError.code;
	}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch.Headers" id="apidoc.module.node-fetch.Headers">module node-fetch.Headers</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.Headers.Headers" id="apidoc.element.node-fetch.Headers.Headers">
        function <span class="apidocSignatureSpan">node-fetch.</span>Headers
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Headers(headers) {

	var self = this;
	this._headers = {};

	// Headers
	if (headers instanceof Headers) {
		headers = headers.raw();
	}

	// plain object
	for (var prop in headers) {
		if (!headers.hasOwnProperty(prop)) {
			continue;
		}

		if (typeof headers[prop] === 'string') {
			this.set(prop, headers[prop]);

		} else if (typeof headers[prop] === 'number' &amp;&amp; !isNaN(headers[prop])) {
			this.set(prop, headers[prop].toString());

		} else if (headers[prop] instanceof Array) {
			headers[prop].forEach(function(item) {
				self.append(prop, item.toString());
			});
		}
	}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch.Headers.prototype" id="apidoc.module.node-fetch.Headers.prototype">module node-fetch.Headers.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.Headers.prototype.append" id="apidoc.element.node-fetch.Headers.prototype.append">
        function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>append
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function (name, value) {
	if (!this.has(name)) {
		this.set(name, value);
		return;
	}

	this._headers[name.toLowerCase()].push(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		console.log(json);
	});

// post with form-data (detect multipart)

var FormData = require('form-data');
var form = new FormData();
form.<span class="apidocCodeKeywordSpan">append</span>('a', 1);
fetch('http://httpbin.org/post', { method: 'POST', body: form })
	.then(function(res) {
		return res.json();
	}).then(function(json) {
		console.log(json);
	});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.Headers.prototype.delete" id="apidoc.element.node-fetch.Headers.prototype.delete">
        function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>delete
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (name) {
	delete this._headers[name.toLowerCase()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.Headers.prototype.forEach" id="apidoc.element.node-fetch.Headers.prototype.forEach">
        function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback, thisArg) {
	Object.getOwnPropertyNames(this._headers).forEach(function(name) {
		this._headers[name].forEach(function(value) {
			callback.call(thisArg, value, name, this)
		}, this)
	}, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.Headers.prototype.get" id="apidoc.element.node-fetch.Headers.prototype.get">
        function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>get
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (name) {
	var list = this._headers[name.toLowerCase()];
	return list ? list[0] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

fetch('https://github.com/')
	.then(function(res) {
		console.log(res.ok);
		console.log(res.status);
		console.log(res.statusText);
		console.log(res.headers.raw());
		console.log(res.headers.<span class="apidocCodeKeywordSpan">get</span>('content-type'));
	});

// post

fetch('http://httpbin.org/post', { method: 'POST', body: 'a=1' })
	.then(function(res) {
		return res.json();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.Headers.prototype.getAll" id="apidoc.element.node-fetch.Headers.prototype.getAll">
        function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>getAll
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAll = function (name) {
	if (!this.has(name)) {
		return [];
	}

	return this._headers[name.toLowerCase()];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.Headers.prototype.has" id="apidoc.element.node-fetch.Headers.prototype.has">
        function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>has
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (name) {
	return this._headers.hasOwnProperty(name.toLowerCase());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		// normalize headers
		var headers = new Headers(options.headers);

		if (options.compress) {
			headers.set('accept-encoding', 'gzip,deflate');
		}

		if (!headers.<span class="apidocCodeKeywordSpan">has</span>('user-agent')) {
			headers.set('user-agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
		}

		if (!headers.has('connection') &amp;&amp; !options.agent) {
			headers.set('connection', 'close');
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.Headers.prototype.raw" id="apidoc.element.node-fetch.Headers.prototype.raw">
        function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>raw
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">raw = function () {
	return this._headers;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// meta

fetch('https://github.com/')
	.then(function(res) {
		console.log(res.ok);
		console.log(res.status);
		console.log(res.statusText);
		console.log(res.headers.<span class="apidocCodeKeywordSpan">raw</span>());
		console.log(res.headers.get('content-type'));
	});

// post

fetch('http://httpbin.org/post', { method: 'POST', body: 'a=1' })
	.then(function(res) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.Headers.prototype.set" id="apidoc.element.node-fetch.Headers.prototype.set">
        function <span class="apidocSignatureSpan">node-fetch.Headers.prototype.</span>set
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (name, value) {
	this._headers[name.toLowerCase()] = [value];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			send = http.request;
		}

		// normalize headers
		var headers = new Headers(options.headers);

		if (options.compress) {
			headers.<span class="apidocCodeKeywordSpan">set</span>('accept-encoding', 'gzip,deflate');
		}

		if (!headers.has('user-agent')) {
			headers.set('user-agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
		}

		if (!headers.has('connection') &amp;&amp; !options.agent) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch.Request" id="apidoc.module.node-fetch.Request">module node-fetch.Request</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.Request.Request" id="apidoc.element.node-fetch.Request.Request">
        function <span class="apidocSignatureSpan">node-fetch.</span>Request
        <span class="apidocSignatureSpan">(input, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Request(input, init) {
	var url, url_parsed;

	// normalize input
	if (!(input instanceof Request)) {
		url = input;
		url_parsed = parse_url(url);
		input = {};
	} else {
		url = input.url;
		url_parsed = parse_url(url);
	}

	// normalize init
	init = init || {};

	// fetch spec options
	this.method = init.method || input.method || 'GET';
	this.redirect = init.redirect || input.redirect || 'follow';
	this.headers = new Headers(init.headers || input.headers || {});
	this.url = url;

	// server only options
	this.follow = init.follow !== undefined ?
		init.follow : input.follow !== undefined ?
		input.follow : 20;
	this.compress = init.compress !== undefined ?
		init.compress : input.compress !== undefined ?
		input.compress : true;
	this.counter = init.counter || input.counter || 0;
	this.agent = init.agent || input.agent;

	Body.call(this, init.body || this._clone(input), {
		timeout: init.timeout || input.timeout || 0,
		size: init.size || input.size || 0
	});

	// server request options
	this.protocol = url_parsed.protocol;
	this.hostname = url_parsed.hostname;
	this.port = url_parsed.port;
	this.path = url_parsed.path;
	this.auth = url_parsed.auth;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch.Request.prototype" id="apidoc.module.node-fetch.Request.prototype">module node-fetch.Request.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.Request.prototype.clone" id="apidoc.element.node-fetch.Request.prototype.clone">
        function <span class="apidocSignatureSpan">node-fetch.Request.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
	return new Request(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch.Response" id="apidoc.module.node-fetch.Response">module node-fetch.Response</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.Response.Response" id="apidoc.element.node-fetch.Response.Response">
        function <span class="apidocSignatureSpan">node-fetch.</span>Response
        <span class="apidocSignatureSpan">(body, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Response(body, opts) {

	opts = opts || {};

	this.url = opts.url;
	this.status = opts.status || 200;
	this.statusText = opts.statusText || http.STATUS_CODES[this.status];
	this.headers = new Headers(opts.headers);
	this.ok = this.status &gt;= 200 &amp;&amp; this.status &lt; 300;

	Body.call(this, body, opts);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch.Response.prototype" id="apidoc.module.node-fetch.Response.prototype">module node-fetch.Response.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.Response.prototype.clone" id="apidoc.element.node-fetch.Response.prototype.clone">
        function <span class="apidocSignatureSpan">node-fetch.Response.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
	return new Response(this._clone(this), {
		url: this.url
		, status: this.status
		, statusText: this.statusText
		, headers: this.headers
		, ok: this.ok
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch.body" id="apidoc.module.node-fetch.body">module node-fetch.body</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.body.body" id="apidoc.element.node-fetch.body.body">
        function <span class="apidocSignatureSpan">node-fetch.</span>body
        <span class="apidocSignatureSpan">(body, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Body(body, opts) {

	opts = opts || {};

	this.body = body;
	this.bodyUsed = false;
	this.size = opts.size || 0;
	this.timeout = opts.timeout || 0;
	this._raw = [];
	this._abort = false;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.body.Promise" id="apidoc.element.node-fetch.body.Promise">
        function <span class="apidocSignatureSpan">node-fetch.body.</span>Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}

	Body.Promise = Fetch.Promise;

	var self = this;

	// wrap http.request into fetch
	return new Fetch.<span class="apidocCodeKeywordSpan">Promise</span>(function(resolve, reject) {
		// build request object
		var options = new Request(url, opts);

		if (!options.protocol || !options.hostname) {
			throw new Error('only absolute urls are supported');
		}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch.body.prototype" id="apidoc.module.node-fetch.body.prototype">module node-fetch.body.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.body.prototype._clone" id="apidoc.element.node-fetch.body.prototype._clone">
        function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>_clone
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_clone = function (instance) {
	var p1, p2;
	var body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (bodyStream(body) &amp;&amp; typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance.body = p1;
		body = p2;
	}

	return body;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.body.prototype._convert" id="apidoc.element.node-fetch.body.prototype._convert">
        function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>_convert
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_convert = function (encoding) {

	encoding = encoding || 'utf-8';

	var ct = this.headers.get('content-type');
	var charset = 'utf-8';
	var res, str;

	// header
	if (ct) {
		// skip encoding detection altogether if not html/xml/plain text
		if (!/text\/html|text\/plain|\+xml|\/xml/i.test(ct)) {
			return Buffer.concat(this._raw);
		}

		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	if (!res &amp;&amp; this._raw.length &gt; 0) {
		for (var i = 0; i &lt; this._raw.length; i++) {
			str += this._raw[i].toString()
			if (str.length &gt; 1024) {
				break;
			}
		}
		str = str.substr(0, 1024);
	}

	// html5
	if (!res &amp;&amp; str) {
		res = /&lt;meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res &amp;&amp; str) {
		res = /&lt;meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res &amp;&amp; str) {
		res = /&lt;\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(
		Buffer.concat(this._raw)
		, encoding
		, charset
	);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	return new Body.Promise(function(resolve, reject) {
		var resTimeout;

		// body is string
		if (typeof self.body === 'string') {
			self._bytes = self.body.length;
			self._raw = [new Buffer(self.body)];
			return resolve(self.<span class="apidocCodeKeywordSpan">_convert</span>());
		}

		// body is buffer
		if (self.body instanceof Buffer) {
			self._bytes = self.body.length;
			self._raw = [self.body];
			return resolve(self._convert());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.body.prototype._decode" id="apidoc.element.node-fetch.body.prototype._decode">
        function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>_decode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_decode = function () {

	var self = this;

	if (this.bodyUsed) {
		return Body.Promise.reject(new Error('body used already for: ' + this.url));
	}

	this.bodyUsed = true;
	this._bytes = 0;
	this._abort = false;
	this._raw = [];

	return new Body.Promise(function(resolve, reject) {
		var resTimeout;

		// body is string
		if (typeof self.body === 'string') {
			self._bytes = self.body.length;
			self._raw = [new Buffer(self.body)];
			return resolve(self._convert());
		}

		// body is buffer
		if (self.body instanceof Buffer) {
			self._bytes = self.body.length;
			self._raw = [self.body];
			return resolve(self._convert());
		}

		// allow timeout on slow response body
		if (self.timeout) {
			resTimeout = setTimeout(function() {
				self._abort = true;
				reject(new FetchError('response timeout at ' + self.url + ' over limit: ' + self.timeout, 'body-timeout'));
			}, self.timeout);
		}

		// handle stream error, such as incorrect content-encoding
		self.body.on('error', function(err) {
			reject(new FetchError('invalid response body at: ' + self.url + ' reason: ' + err.message, 'system', err));
		});

		// body is stream
		self.body.on('data', function(chunk) {
			if (self._abort || chunk === null) {
				return;
			}

			if (self.size &amp;&amp; self._bytes + chunk.length &gt; self.size) {
				self._abort = true;
				reject(new FetchError('content size at ' + self.url + ' over limit: ' + self.size, 'max-size'));
				return;
			}

			self._bytes += chunk.length;
			self._raw.push(chunk);
		});

		self.body.on('end', function() {
			if (self._abort) {
				return;
			}

			clearTimeout(resTimeout);
			resolve(self._convert());
		});
	});

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Body.prototype.json = function() {

	// for 204 No Content response, buffer will be empty, parsing it will throw error
	if (this.status === 204) {
		return Body.Promise.resolve({});
	}

	return this.<span class="apidocCodeKeywordSpan">_decode</span>().then(function(buffer) {
		return JSON.parse(buffer.toString());
	});

};

/**
* Decode response as text
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.body.prototype.buffer" id="apidoc.element.node-fetch.body.prototype.buffer">
        function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>buffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buffer = function () {

	return this._decode();

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// buffer
// if you prefer to cache binary data in full, use buffer()
// note that buffer() is a node-fetch only API

var fileType = require('file-type');
fetch('https://assets-cdn.github.com/images/modules/logos_page/Octocat.png')
	.then(function(res) {
		return res.<span class="apidocCodeKeywordSpan">buffer</span>();
	}).then(function(buffer) {
		fileType(buffer);
	});

// meta

fetch('https://github.com/')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.body.prototype.json" id="apidoc.element.node-fetch.body.prototype.json">
        function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>json
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">json = function () {

	// for 204 No Content response, buffer will be empty, parsing it will throw error
	if (this.status === 204) {
		return Body.Promise.resolve({});
	}

	return this._decode().then(function(buffer) {
		return JSON.parse(buffer.toString());
	});

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# Features

- Stay consistent with `window.fetch` API.
- Make conscious trade-off when following [whatwg fetch spec](https://fetch.spec.whatwg.org/) and [stream spec](https://streams.
spec.whatwg.org/) implementation details, document known difference.
- Use native promise, but allow substituting it with [insert your favorite promise library].
- Use native stream for body, on both request and response.
- Decode content encoding (gzip/deflate) properly, and convert string output (such as `res.text()` and `res.<span class="apidocCodeKeywordSpan
">json</span>()`) to UTF-8 automatically.
- Useful extensions such as timeout, redirect limit, response size limit, [explicit errors](https://github.com/bitinn/node-fetch
/blob/master/ERROR-HANDLING.md) for troubleshooting.


# Difference from client-side fetch

- See [Known Differences](https://github.com/bitinn/node-fetch/blob/master/LIMITS.md) for details.
- If you happen to use a missing feature that `window.fetch` offers, feel free to open an issue.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.body.prototype.text" id="apidoc.element.node-fetch.body.prototype.text">
        function <span class="apidocSignatureSpan">node-fetch.body.prototype.</span>text
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function () {

	return this._decode().then(function(buffer) {
		return buffer.toString();
	});

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# Features

- Stay consistent with `window.fetch` API.
- Make conscious trade-off when following [whatwg fetch spec](https://fetch.spec.whatwg.org/) and [stream spec](https://streams.
spec.whatwg.org/) implementation details, document known difference.
- Use native promise, but allow substituting it with [insert your favorite promise library].
- Use native stream for body, on both request and response.
- Decode content encoding (gzip/deflate) properly, and convert string output (such as `res.<span class="apidocCodeKeywordSpan">text
</span>()` and `res.json()`) to UTF-8 automatically.
- Useful extensions such as timeout, redirect limit, response size limit, [explicit errors](https://github.com/bitinn/node-fetch
/blob/master/ERROR-HANDLING.md) for troubleshooting.


# Difference from client-side fetch

- See [Known Differences](https://github.com/bitinn/node-fetch/blob/master/LIMITS.md) for details.
- If you happen to use a missing feature that `window.fetch` offers, feel free to open an issue.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch.default" id="apidoc.module.node-fetch.default">module node-fetch.default</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.default.default" id="apidoc.element.node-fetch.default.default">
        function <span class="apidocSignatureSpan">node-fetch.</span>default
        <span class="apidocSignatureSpan">(url, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Fetch(url, opts) {

	// allow call as function
	if (!(this instanceof Fetch))
		return new Fetch(url, opts);

	// allow custom promise
	if (!Fetch.Promise) {
		throw new Error('native promise missing, set Fetch.Promise to your favorite alternative');
	}

	Body.Promise = Fetch.Promise;

	var self = this;

	// wrap http.request into fetch
	return new Fetch.Promise(function(resolve, reject) {
		// build request object
		var options = new Request(url, opts);

		if (!options.protocol || !options.hostname) {
			throw new Error('only absolute urls are supported');
		}

		if (options.protocol !== 'http:' &amp;&amp; options.protocol !== 'https:') {
			throw new Error('only http(s) protocols are supported');
		}

		var send;
		if (options.protocol === 'https:') {
			send = https.request;
		} else {
			send = http.request;
		}

		// normalize headers
		var headers = new Headers(options.headers);

		if (options.compress) {
			headers.set('accept-encoding', 'gzip,deflate');
		}

		if (!headers.has('user-agent')) {
			headers.set('user-agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
		}

		if (!headers.has('connection') &amp;&amp; !options.agent) {
			headers.set('connection', 'close');
		}

		if (!headers.has('accept')) {
			headers.set('accept', '*/*');
		}

		// detect form data input from form-data module, this hack avoid the need to pass multipart header manually
		if (!headers.has('content-type') &amp;&amp; options.body &amp;&amp; typeof options.body.getBoundary === 'function') {
			headers.set('content-type', 'multipart/form-data; boundary=' + options.body.getBoundary());
		}

		// bring node-fetch closer to browser behavior by setting content-length automatically
		if (!headers.has('content-length') &amp;&amp; /post|put|patch|delete/i.test(options.method)) {
			if (typeof options.body === 'string') {
				headers.set('content-length', Buffer.byteLength(options.body));
			// detect form data input from form-data module, this hack avoid the need to add content-length header manually
			} else if (options.body &amp;&amp; typeof options.body.getLengthSync === 'function') {
				// for form-data 1.x
				if (options.body._lengthRetrievers &amp;&amp; options.body._lengthRetrievers.length == 0) {
					headers.set('content-length', options.body.getLengthSync().toString());
				// for form-data 2.x
				} else if (options.body.hasKnownLength &amp;&amp; options.body.hasKnownLength()) {
					headers.set('content-length', options.body.getLengthSync().toString());
				}
			// this is only necessary for older nodejs releases (before iojs merge)
			} else if (options.body === undefined || options.body === null) {
				headers.set('content-length', '0');
			}
		}

		options.headers = headers.raw();

		// http.request only support string as host header, this hack make custom host header possible
		if (options.headers.host) {
			options.headers.host = options.headers.host[0];
		}

		// send request
		var req = send(options);
		var reqTimeout;

		if (options.timeout) {
			req.once('socket', function(socket) {
				reqTimeout = setTimeout(function() {
					req.abort();
					reject(new FetchError('network timeout at: ' + options.url, 'request-timeout'));
				}, options.timeout);
			});
		}

		req.on('error', function(err) {
			clearTimeout(reqTimeout);
			reject(new FetchError('request to ' + options.url + ' failed, reason: ' + err.message, 'system', err));
		});

		req.on('response', function(res) {
			clearTimeout(reqTimeout);

			// handle redirect
			if (self.isRedirect(res.statusCode) &amp;&amp; options.redirect !== 'manual') {
				if (options.redirect === 'error') {
					reject(new FetchError('redirect mode is set to error: ' + options.url, 'no-redirect'));
					return;
				}

				if (options.counter &gt;= options.follow) {
					reject(new FetchError('maximum redirect reached at: ' + options.url, 'max-redirect'));
					return;
				}

				if (!res.headers.location) {
					reject(new FetchError('redirect location header missing at: ' + options.url, 'invalid-redirect'));
					return;
				}

				// per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET wh ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.default.Headers" id="apidoc.element.node-fetch.default.Headers">
        function <span class="apidocSignatureSpan">node-fetch.default.</span>Headers
        <span class="apidocSignatureSpan">(headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Headers(headers) {

	var self = this;
	this._headers = {};

	// Headers
	if (headers instanceof Headers) {
		headers = headers.raw();
	}

	// plain object
	for (var prop in headers) {
		if (!headers.hasOwnProperty(prop)) {
			continue;
		}

		if (typeof headers[prop] === 'string') {
			this.set(prop, headers[prop]);

		} else if (typeof headers[prop] === 'number' &amp;&amp; !isNaN(headers[prop])) {
			this.set(prop, headers[prop].toString());

		} else if (headers[prop] instanceof Array) {
			headers[prop].forEach(function(item) {
				self.append(prop, item.toString());
			});
		}
	}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.default.Promise" id="apidoc.element.node-fetch.default.Promise">
        function <span class="apidocSignatureSpan">node-fetch.default.</span>Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	}

	Body.Promise = Fetch.Promise;

	var self = this;

	// wrap http.request into fetch
	return new Fetch.<span class="apidocCodeKeywordSpan">Promise</span>(function(resolve, reject) {
		// build request object
		var options = new Request(url, opts);

		if (!options.protocol || !options.hostname) {
			throw new Error('only absolute urls are supported');
		}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.default.Request" id="apidoc.element.node-fetch.default.Request">
        function <span class="apidocSignatureSpan">node-fetch.default.</span>Request
        <span class="apidocSignatureSpan">(input, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Request(input, init) {
	var url, url_parsed;

	// normalize input
	if (!(input instanceof Request)) {
		url = input;
		url_parsed = parse_url(url);
		input = {};
	} else {
		url = input.url;
		url_parsed = parse_url(url);
	}

	// normalize init
	init = init || {};

	// fetch spec options
	this.method = init.method || input.method || 'GET';
	this.redirect = init.redirect || input.redirect || 'follow';
	this.headers = new Headers(init.headers || input.headers || {});
	this.url = url;

	// server only options
	this.follow = init.follow !== undefined ?
		init.follow : input.follow !== undefined ?
		input.follow : 20;
	this.compress = init.compress !== undefined ?
		init.compress : input.compress !== undefined ?
		input.compress : true;
	this.counter = init.counter || input.counter || 0;
	this.agent = init.agent || input.agent;

	Body.call(this, init.body || this._clone(input), {
		timeout: init.timeout || input.timeout || 0,
		size: init.size || input.size || 0
	});

	// server request options
	this.protocol = url_parsed.protocol;
	this.hostname = url_parsed.hostname;
	this.port = url_parsed.port;
	this.path = url_parsed.path;
	this.auth = url_parsed.auth;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.default.Response" id="apidoc.element.node-fetch.default.Response">
        function <span class="apidocSignatureSpan">node-fetch.default.</span>Response
        <span class="apidocSignatureSpan">(body, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Response(body, opts) {

	opts = opts || {};

	this.url = opts.url;
	this.status = opts.status || 200;
	this.statusText = opts.statusText || http.STATUS_CODES[this.status];
	this.headers = new Headers(opts.headers);
	this.ok = this.status &gt;= 200 &amp;&amp; this.status &lt; 300;

	Body.call(this, body, opts);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch.default.prototype" id="apidoc.module.node-fetch.default.prototype">module node-fetch.default.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.default.prototype.isRedirect" id="apidoc.element.node-fetch.default.prototype.isRedirect">
        function <span class="apidocSignatureSpan">node-fetch.default.prototype.</span>isRedirect
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			reject(new FetchError('request to ' + options.url + ' failed, reason: ' + err.message, 'system',
err));
		});

		req.on('response', function(res) {
			clearTimeout(reqTimeout);

			// handle redirect
			if (self.<span class="apidocCodeKeywordSpan">isRedirect</span>(res.statusCode) &amp;&amp; options.redirect !== 'manual
') {
				if (options.redirect === 'error') {
					reject(new FetchError('redirect mode is set to error: ' + options.url, 'no-redirect'));
					return;
				}

				if (options.counter &gt;= options.follow) {
					reject(new FetchError('maximum redirect reached at: ' + options.url, 'max-redirect'));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.node-fetch.fetch_error" id="apidoc.module.node-fetch.fetch_error">module node-fetch.fetch_error</a></h1>


    <h2>
        <a href="#apidoc.element.node-fetch.fetch_error.fetch_error" id="apidoc.element.node-fetch.fetch_error.fetch_error">
        function <span class="apidocSignatureSpan">node-fetch.</span>fetch_error
        <span class="apidocSignatureSpan">(message, type, systemError)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FetchError(message, type, systemError) {

	// hide custom error implementation details from end-users
	Error.captureStackTrace(this, this.constructor);

	this.name = this.constructor.name;
	this.message = message;
	this.type = type;

	// when err.type is `system`, err.code contains system error code
	if (systemError) {
		this.code = this.errno = systemError.code;
	}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.node-fetch.fetch_error.super_" id="apidoc.element.node-fetch.fetch_error.super_">
        function <span class="apidocSignatureSpan">node-fetch.fetch_error.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>